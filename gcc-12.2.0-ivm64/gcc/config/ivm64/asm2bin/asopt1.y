%{
    /* IVM64 assembler
       Parser for optimization phase (for native assembly from phase 0)
       Author: Eladio Gutierrez
               University of Malaga, Spain
       Jan 2022
    */

    /* This program introduces some optimizations to the
       native ivm64 assembly code generated by stage as0.
       Usage:
            as0 < prog.s | asopt1 | as1 > prog.bin
    */

    #define IVM64_BISON_AS_OPTIMIZER_VERSION "v2.0"
    #include <stdio.h>
    int yylex(void);
    void yyerror(const char*);
    extern int noerror; /*Defined in .l*/
    extern void yyrestart(FILE*);

    #define YYERROR_VERBOSE 1
    extern int yylineno;

    /* Verbose info */
    #define IVM64_BISON_AS_OPT_VERBOSE 0

    #define IVM64_BISON_AS_OPT1
    #include "ivm64_helper_bison.c"

    /* Where to write, in stdout or initialization file*/
    FILE* out_file;

    /* A syntactic tree is made of these nodes */
    union yystype_u {
        uint8_t    opcode;
        int64_t    num;     /* VAL_NUM */
        char       *label;  /* VAL_STR */
    };

    typedef enum valtype_e {VAL_UNUSED, VAL_OPCODE, VAL_NUM, VAL_STR} valtype_t;

    #define IVM_MAX_OPERANDS 8
    typedef struct tree_node_s {
        long token;  /* lex data */

        valtype_t  valtype; /* What kind of val is stored (number, label ...)*/
        //YYSTYPE val;
        union yystype_u val;

        char * insn; /* assembly instruction, not used for now */

        int nops;    /* number of operands */
        int npush;   /* number of element pushed in the stack by the instruction of this node */

        struct tree_node_s* ops[IVM_MAX_OPERANDS];  /* operands (a list of pointers to tree) */

        int mention_sp; /* Some operand has GETSP in its subtrees */
    } tree_node;


    /* A stack with the trees:
        TStack[0],[1],[2] ... -> each entry is a tree */
    /* At most a tree per native instruction */
    #define IVM64_BISON_MAX_PROG_SIZE 1024*1024*16
    tree_node **TStack;

    /* Indexes in the stack where the current basic block starts/ends */
    long bb0=0, bbE=-1;

    /* Used to annotate how many elements an instruction left on the stack */
    int npush = 0;

    /* Functions defined later */
    tree_node* new_tree(long tok, valtype_t valtype, union yystype_u val, int npush, tree_node *op0, tree_node *op1, tree_node *op2);
    void push_tree(tree_node *t);
    tree_node* pop_tree();
    int tree_pop_available(int n);
    void print_current_bb();
    void optimize_current_bb();

    /* Variables for debugging */
    int n_insn = 0; /* Number of tree nodes (native instructions/directives) printed */
    int n_max_stack = 0;  /* Maximum number of tree nodes in the stack */
    int n_opt = 0;

%}

/* These declare our output file names. */
/* This is not POSIX compliant */
//%output "y.tab.0.c"
//%defines "y.tab.0.h"

/* The field names of this union are used as return types for
   the tokens both in the lexer and the parser*/
%union {
    uint8_t    opcode;
    int64_t    num;
    char       *label;
}

/* White spaces */
%token TOKEN_WS

/* Constant operands*/
%token <num>TOKEN_NUM
%token <label>TOKEN_LABEL
%token <label>TOKEN_NEAR_LABEL
%token <label>TOKEN_LABEL_DECL
%token <label>TOKEN_ALIAS

/* Native instructions */
%token <label>TOKEN_EXIT
%token <label>TOKEN_NOP
%token <label>TOKEN_JUMP
%token <label>TOKEN_JZFWD
%token <label>TOKEN_JZBACK
%token <label>TOKEN_SETSP
%token <label>TOKEN_GETPC
%token <label>TOKEN_GETSP
%token <label>TOKEN_PUSH0
%token <label>TOKEN_PUSH1
%token <label>TOKEN_PUSH2
%token <label>TOKEN_PUSH4
%token <label>TOKEN_PUSH8
%token <label>TOKEN_LOAD1
%token <label>TOKEN_LOAD2
%token <label>TOKEN_LOAD4
%token <label>TOKEN_LOAD8
%token <label>TOKEN_STORE1
%token <label>TOKEN_STORE2
%token <label>TOKEN_STORE4
%token <label>TOKEN_STORE8
%token <label>TOKEN_ADD
%token <label>TOKEN_MULT
%token <label>TOKEN_DIV
%token <label>TOKEN_REM
%token <label>TOKEN_LT
%token <label>TOKEN_AND
%token <label>TOKEN_OR
%token <label>TOKEN_NOT
%token <label>TOKEN_XOR
%token <label>TOKEN_POW
%token <label>TOKEN_CHECK
%token <label>TOKEN_PUTBYTE
%token <label>TOKEN_READCHAR
%token <label>TOKEN_PUTCHAR
%token <label>TOKEN_ADDSAMPLE
%token <label>TOKEN_SETPIXEL
%token <label>TOKEN_NEWFRAME
%token <label>TOKEN_READPIXEL
%token <label>TOKEN_READFRAME

/* Directives */
%token <label>TOKEN_DATA

%token TOKEN_UNKNOWN

/* These tokens are for bison private use,
   not returned by lex */
%token <opcode>TOKEN_INSN
%token <opcode>TOKEN_PUSH_LABEL_PLUS_CONST


/* Type of non-terminal symbols */
%type <opcode>incond_jump_insn
/* Native insn's with 0,1,2,3 and 5 operands */
%type <label>no_op_insn
%type <label>one_op_insn
%type <label>two_op_insn
/* Native instruction with 3 or more operands */
%type <label>side_effect_insn

/* For these return the token */
%type <num>push_mnemonic

%%

/* A valid assembly program is made of a
   sequence of valid statements */
assembler: prog   {/* Valid program */}

prog:
    /* empty */
  | prog statement
  ;

statement:
    closing_statement { /* 1. process trees (optimize and print) from bb0, bbE; */
                        optimize_current_bb();
                        print_current_bb();

                        /* 2. reset bbE to bb0, that is, start a new basic block */
                        n_max_stack = ((bbE-bb0+1)>n_max_stack)?(bbE-bb0+1):n_max_stack; // For statistics
                        //bb0 = bbE + 1;
                        bbE=-1;
                        //static long nbb=0;
                        // fprintf(stderr, "\n-> New bb %ld (bbE=%ld) starts in line %d\n", ++nbb, bbE, yylineno+1); //debug
                      }
  | normal_statement
  ;

closing_statement:    /*statement closing a BB*/
    label_declaration
  | directive
  | alias
  | cond_jump_insn
  | incond_jump_insn
  | side_effect_insn { tree_node* t = new_tree(TOKEN_INSN, VAL_STR, (union yystype_u)($1), 0, NULL, NULL, NULL);
                       push_tree(t); free($1);}

normal_statement:
    push_insn
  | no_op_insn    {
                     tree_node* t = new_tree(TOKEN_INSN, VAL_STR, (union yystype_u)($1), npush, NULL, NULL, NULL);
                     push_tree(t);
                     free($1);
                  }
  | one_op_insn   {
                      if (tree_pop_available(1)){
                         /* There is one operand to pop: make the tree for this native insn with one operand */
                         tree_node* op0 = pop_tree();
                         tree_node* t = new_tree(TOKEN_INSN, VAL_STR, (union yystype_u)($1), npush, op0, NULL, NULL);
                         push_tree(t);
                         free($1);
                      } else {
                         /* There is NO operand to pop: make the tree for this native insn with zero operand */
                         tree_node* t = new_tree(TOKEN_INSN, VAL_STR, (union yystype_u)($1), npush, NULL, NULL, NULL);
                         push_tree(t);
                         free($1);
                      }
                  }
  | two_op_insn   {
                      if (tree_pop_available(2)){
                         /* There is one operand to pop: make the tree for this native insn with one operand */
                         tree_node* op1 = pop_tree();
                         tree_node* op0 = pop_tree();
                         tree_node* t = new_tree(TOKEN_INSN, VAL_STR, (union yystype_u)($1), npush, op0, op1, NULL);
                         push_tree(t);
                         free($1);
                      } else {
                         /* There is NO operand to pop: make the tree for this native insn with zero operand */
                         tree_node* t = new_tree(TOKEN_INSN, VAL_STR, (union yystype_u)($1), npush, NULL, NULL, NULL);
                         push_tree(t);
                         free($1);
                      }
                  }
  ;


push_insn:
    TOKEN_PUSH0 {
                  /* 'push0' will be treated as 'push1 0' as make optimization easier */
                  int64_t z = 0;
                  tree_node* t = new_tree(TOKEN_PUSH1, VAL_NUM, (union yystype_u)z, 1, NULL, NULL, NULL);
                  push_tree(t);
                }
  | push_mnemonic TOKEN_NUM {
                             tree_node* t = new_tree($1, VAL_NUM, (union yystype_u)$2, 1, NULL, NULL, NULL);
                             push_tree(t);
                            }
  | push_mnemonic TOKEN_LABEL {
                                tree_node* t = new_tree($1, VAL_STR, (union yystype_u)($2), 1, NULL, NULL, NULL);
                                push_tree(t);
                                free($2);
                              }
  | push_mnemonic TOKEN_NEAR_LABEL {
                                tree_node* t = new_tree($1, VAL_STR, (union yystype_u)($2), 1, NULL, NULL, NULL);
                                push_tree(t);
                                free($2);
                              }
  ;


push_mnemonic:
    TOKEN_PUSH1 {$$=TOKEN_PUSH1;}
  | TOKEN_PUSH2 {$$=TOKEN_PUSH2;}
  | TOKEN_PUSH4 {$$=TOKEN_PUSH4;}
  | TOKEN_PUSH8 {$$=TOKEN_PUSH8;}
  ;

/* The operand of conditional instructions is always 1-byte wide */
cond_jump_insn:
    TOKEN_JZFWD TOKEN_NUM   {
                             tree_node* t = new_tree(TOKEN_JZFWD, VAL_NUM, (union yystype_u)$2, 0, NULL, NULL, NULL);
                             push_tree(t);
                            }
  | TOKEN_JZBACK TOKEN_NUM  {
                             tree_node* t = new_tree(TOKEN_JZBACK, VAL_NUM, (union yystype_u)$2, 0, NULL, NULL, NULL);
                             push_tree(t);
                            }
  | jz_to_label_insn
  ;

/* "jzfwd label" is an optimized form that can be
   written in different ways in the binary depending on the label:
   "jzfwd N" "jzback N" or "push label jmp".
   Observe that although mnemonic jzfwd is used, it can be
   a backward jump */
jz_to_label_insn:
    TOKEN_JZFWD TOKEN_LABEL  {
                                /* implement jz to label*/
                                tree_node* t = new_tree(TOKEN_JZFWD, VAL_STR, (union yystype_u)($2), 0, NULL, NULL, NULL);
                                push_tree(t);
                                free($2);
                             }
  |  TOKEN_JZFWD TOKEN_NEAR_LABEL  {
                                /* implement jzfwd to a short label (known to be near)*/
                                tree_node* t = new_tree(TOKEN_JZFWD, VAL_STR, (union yystype_u)($2), 0, NULL, NULL, NULL);
                                push_tree(t);
                                free($2);
                             }
  ;

incond_jump_insn:
   TOKEN_JUMP TOKEN_LABEL{
                           /* implement jump to label*/
                            tree_node* t = new_tree(TOKEN_JUMP, VAL_STR, (union yystype_u)($2), 0, NULL, NULL, NULL);
                            push_tree(t);
                            free($2);
                          }
  ;

no_op_insn:
    TOKEN_NOP        {npush = 0;}
  | TOKEN_GETPC      {npush = 1;}
  | TOKEN_GETSP      {npush = 1;}
  | TOKEN_READFRAME  {npush = 0;}
  | TOKEN_SETSP      {npush = 0;}
  ;

one_op_insn:
    TOKEN_LOAD1      {npush = 1;}
  | TOKEN_LOAD2      {npush = 1;}
  | TOKEN_LOAD4      {npush = 1;}
  | TOKEN_LOAD8      {npush = 1;}
  | TOKEN_NOT        {npush = 1;}
  | TOKEN_POW        {npush = 1;}
  ;

two_op_insn:
    TOKEN_STORE1      {npush = 0;}
  | TOKEN_STORE2      {npush = 0;}
  | TOKEN_STORE4      {npush = 0;}
  | TOKEN_STORE8      {npush = 0;}
  | TOKEN_ADD         {npush = 1;}
  | TOKEN_MULT        {npush = 1;}
  | TOKEN_DIV         {npush = 1;}
  | TOKEN_REM         {npush = 1;}
  | TOKEN_LT          {npush = 1;}
  | TOKEN_AND         {npush = 1;}
  | TOKEN_OR          {npush = 1;}
  | TOKEN_XOR         {npush = 1;}
  ;

/* Instructions that ends a basic block
   and cannot be optimized. It includes
   all I/O, and other specials. These are handled
   as insn without operands but starting a
   new basic block */
side_effect_insn:
    TOKEN_EXIT
  | TOKEN_JUMP
  | TOKEN_CHECK
  | TOKEN_PUTBYTE
  | TOKEN_READCHAR
  | TOKEN_PUTCHAR
  | TOKEN_NEWFRAME
  | TOKEN_READPIXEL
  | TOKEN_SETPIXEL
  | TOKEN_ADDSAMPLE
  ;

label_declaration:
    TOKEN_LABEL_DECL {
                       tree_node* t = new_tree(TOKEN_LABEL_DECL, VAL_STR, (union yystype_u)($1), 0, NULL, NULL, NULL);
                       push_tree(t);
                       // fprintf(stderr, "  this node is a label decl. '%s:'\n", $1); //debug
                       free($1);
                     }
  ;

directive:
    data
  ;

data:
    TOKEN_DATA {
                 tree_node* t = new_tree(TOKEN_DATA, VAL_STR, (union yystype_u)($1), 0, NULL, NULL, NULL);
                 push_tree(t);
                 free($1);
                 // fprintf(stderr, "  this node is a data directive: '%s'\n", $1); //debug
               }
alias:
    TOKEN_ALIAS TOKEN_LABEL { /* Rebuild the alias declaration val="$1=$2" for this token*/
                                    char* s = (char*)alloca((strlen($1)+strlen($2)+8)*sizeof(char));
                                    sprintf(s, "%s=%s", $1, $2);
                                    tree_node* t = new_tree(TOKEN_ALIAS, VAL_STR, (union yystype_u)(s), 0, NULL, NULL, NULL);
                                    push_tree(t);
                                    free($1);
                                    free($2);
                                  }
  | TOKEN_ALIAS TOKEN_NUM   { /* Rebuild the alias declaration val="$1=$2" for this token*/
                                    char* s = (char*)alloca((strlen($1)+64)*sizeof(char));
                                    sprintf(s, "%s=%ld", $1, $2);
                                    tree_node* t = new_tree(TOKEN_ALIAS, VAL_STR, (union yystype_u)(s), 0, NULL, NULL, NULL);
                                    push_tree(t);
                                    free($1);
                                  }

%%

/* Create a new node tree with values
   Notice that if valtype == VAL_STR, the string in val is
   duplicated -> must be taken into account when freeing
   the node */
tree_node* new_tree(long tok, valtype_t valtype, union yystype_u val, int npush, tree_node *op0, tree_node *op1, tree_node *op2){
    tree_node *t = (tree_node *)malloc(sizeof(tree_node));
    t->token = (enum yytokentype)tok;
    t->valtype = valtype;
    if (valtype == VAL_STR)
        t->val.label = strdup(val.label);
    else
        t->val = val;
    t->ops[0] = op0;
    t->ops[1] = op1;
    t->ops[2] = op2;
    t->nops = !!op0 + !!op1 + !!op2 ; /* Number of non-NULL operands */
    t->npush = npush;

    if (t->token == TOKEN_INSN &&  !strcmp("getsp", t->val.label)) {
        t->mention_sp = 1;
    } else {
        t->mention_sp = (op0 && op0->mention_sp) + (op1 && op1->mention_sp) + (op2 && op2->mention_sp);
    }
    return t;
}

/* Copy one node to another already existing */
/* Note that val is duplicated if it is a string,
   but operands continue being pointer to tree nodes */
void copy_tree_node(tree_node *to, tree_node *from){
    *to = *from;
    if (from->valtype == VAL_STR) {
        to->val.label = strdup(from->val.label);
    }
}

/* Free a node that was created with new_tree() */
void free_tree_node(tree_node *t){
    if (t) {
        if (t->valtype == VAL_STR)
            free(t->val.label);
        free(t);
    }
}
/* Free recursively a node that was created with new_tree()
   Use only if this node was NOT copied, and its operands
   (children) can be safely destroyed too*/
void free_tree_node_recursive(tree_node *t){
    if (t) {
        for (int i=0; i < t->nops, i++;) {
            free_tree_node(t->ops[i]);
        }
        free_tree_node(t);
    }
}

void push_tree(tree_node *t){
    if (bbE >= IVM64_BISON_MAX_PROG_SIZE){ /* The tree stack is exhausted */
        fprintf(stderr, "[asopt1] Error: not enough space in tree stack ... asopt1 exiting\n");
        fprintf(out_file, "[asopt1] Error ...\n"); /* Make next stage stop */
        exit(EXIT_FAILURE);
    }
    // fprintf(stderr, "push token %ld\n", t->token); //debug
    TStack[++bbE] = t;
}

tree_node* pop_tree(){
    if (bbE < bb0){ /* Current BB has no elements to pop */
        fprintf(stderr, "[asopt1] Error: no elements to pop ... asopt1 exiting\n");
        fprintf(out_file, "[asopt1] Error ...\n"); /* Make next stage stop */
        exit(EXIT_FAILURE);
    }
    return TStack[bbE--];
}

/* In the current bb, there is n elements in the stack to pop
   which in turn must push operands in the data stack
   (like push8, add, ...)*/
int tree_pop_available(int n){

    if ((bbE-bb0+1) < n) return 0;

    for (long k=0; k<n; k++){ // Last node in the stack is indexed by bbE
       if (TStack[bbE-k]->npush == 0) {
            return 0;
       }
    }

    return 1;
}

#define INSN_SEP " \t"  // Assembly sentences that does not start bb
#define BB_SEP   "\n"   // Assembly sentences starting a new bb
void print_tree_node(tree_node *t, FILE* fd){

    if (!t) {
        fprintf(stderr, "[asopt1] Error: printing null tree ... asopt1 exiting\n");
        fprintf(out_file, "[asopt1] Error ...\n"); /* Make next stage stop */
        exit(EXIT_FAILURE);
    }

    n_insn++;

    long tok = t->token;
    valtype_t valtype = t->valtype;
    union yystype_u val = t->val;
    tree_node *tl = t->ops[0];
    tree_node *tr = t->ops[1];

    /* Optimization: "push label + const"
       This special node contains two push operands, one
       with the label (left), and the other with the constant (right)*/
    /* This is a final node, DO NOT recurse for operands */
    if (tok == TOKEN_PUSH_LABEL_PLUS_CONST) {
        /* TODO: check valtype and that the node is correct */
        fprintf(fd, "push8 %s + %#lx\n" BB_SEP, tl->val.label, tr->val.num);
        return; /* do not recurse */
    }

    /* Print operands recursively */
    for (int i=0; i < t->nops; i++){
        print_tree_node(t->ops[i], fd);
    }

    /* label declaration */
    if (tok == TOKEN_LABEL_DECL) {
       fprintf(fd, "%s:" BB_SEP, val.label);
    }

    /* alias declaration */
    if (tok == TOKEN_ALIAS) {
       fprintf(fd, "%s" BB_SEP, val.label);
    }

    /* push operand */
    if (tok == TOKEN_PUSH1
        || tok == TOKEN_PUSH2
        || tok == TOKEN_PUSH4
        || tok == TOKEN_PUSH8) {
       //fprintf(fd, "%s ", (tok==TOKEN_PUSH1)?"push1":(tok==TOKEN_PUSH2)?"push2":(tok==TOKEN_PUSH4)?"push4":"push8");
       fprintf(fd, "push8 ");  /* as1 will optimize the size of the push when writting the binary */
       if (valtype == VAL_STR) /*push label*/
            fprintf(fd, "%s" INSN_SEP, val.label);
       else                    /*push numeric*/
            fprintf(fd, "%ld" INSN_SEP, val.num);
    }

    /*jzfwd, jzback*/
    if (tok == TOKEN_JZFWD) {
       if (valtype == VAL_STR) /*jzfwd label*/
            fprintf(fd, "jzfwd %s" BB_SEP, val.label);
       else                    /*jzfwd numeric*/
            fprintf(fd, "jzfwd %ld" BB_SEP, val.num);
    }
    if (tok == TOKEN_JZBACK) {
       if (valtype == VAL_STR) /*jzback label*/
            fprintf(fd, "jzback %s" BB_SEP, val.label);
       else                    /*jzback numeric*/
            fprintf(fd, "jzback %ld" BB_SEP, val.num);
    }

    /*jump label*/
    if (tok == TOKEN_JUMP) {
       if (valtype == VAL_STR)
            fprintf(fd, "jump %s" BB_SEP, val.label);
    }

    /*others native instruction, print mnemonic*/
    if (tok == TOKEN_INSN) {
       if (valtype == VAL_STR)
           fprintf(fd, "%s" INSN_SEP, val.label);
    }

    /* data [] */
    if (tok == TOKEN_DATA) {
      if (valtype == VAL_STR) /* Only data [num] is possible for native assembler */
            fprintf(fd, "%s" BB_SEP, val.label);
    }


}

void print_current_bb(){
    for (long k=bb0; k<=bbE; k++){
        print_tree_node(TStack[k], out_file);
        fprintf(out_file, "\n");
    }
}

#define TREENODE_IS_INSN(t, Mnemonic) (t && (t->token == TOKEN_INSN) && (t->valtype == VAL_STR) && !strcmp((Mnemonic), t->val.label))
#define TREENODE_IS_PUSH(t)  (t && (t->token == TOKEN_PUSH1 || t->token == TOKEN_PUSH2 || t->token == TOKEN_PUSH4 || t->token == TOKEN_PUSH8) )

#define TREENODE_IS_PUSH_CONST(t) (t && TREENODE_IS_PUSH(t) && (t->valtype == VAL_NUM))
// Remember that "push0" is represented as "push1 0"
#define TREENODE_IS_PUSH_CONST0(t) (t && TREENODE_IS_PUSH_CONST(t) && (0 == t->val.num))
#define TREENODE_IS_PUSH_LABEL(t) (t && TREENODE_IS_PUSH(t) && t->valtype == VAL_STR)

#define TREENODE_IS_GETSP(t) (TREENODE_IS_INSN((t), "getsp"))

#define TREENODE_IS_ADD(t)   (TREENODE_IS_INSN((t), "add"))
#define TREENODE_IS_MULT(t)  (TREENODE_IS_INSN((t), "mult"))
#define TREENODE_IS_DIV(t)   (TREENODE_IS_INSN((t), "div"))
#define TREENODE_IS_REM(t)   (TREENODE_IS_INSN((t), "rem"))
#define TREENODE_IS_AND(t)   (TREENODE_IS_INSN((t), "and"))
#define TREENODE_IS_OR(t)    (TREENODE_IS_INSN((t), "or"))
#define TREENODE_IS_XOR(t)   (TREENODE_IS_INSN((t), "xor"))
#define TREENODE_IS_POW(t)   (TREENODE_IS_INSN((t), "pow"))
#define TREENODE_IS_NOT(t)   (TREENODE_IS_INSN((t), "not"))

#define TREENODE_IS_BINARY_OPERATOR(t) (TREENODE_IS_ADD(t) || TREENODE_IS_MULT(t) || TREENODE_IS_DIV(t) || TREENODE_IS_REM(t)|| TREENODE_IS_AND(t) || TREENODE_IS_OR(t)|| TREENODE_IS_XOR(t))
#define TREENODE_IS_UNARY_OPERATOR(t)  (TREENODE_IS_NOT(t) || TREENODE_IS_POW(t))

#define TREENODE_IS_REDUX_OPERATOR(t) (TREENODE_IS_ADD(t) || TREENODE_IS_MULT(t) || TREENODE_IS_AND(t) || TREENODE_IS_OR(t)|| TREENODE_IS_XOR(t))

#define TREENODE_IS_PUSH_LABEL_PLUS_CONST(t) ((t) && (TOKEN_PUSH_LABEL_PLUS_CONST == t->token))

#define TREENODE_EQ_INSN(t1, t2) ((t1) && (t2) &&  (t1->token == TOKEN_INSN) && (t2->token == TOKEN_INSN) &&  !strncmp(t1->val.label, t2->val.label, 32))

// Use this macros to get the node value, after checking that the node is of the right class (TREENODE_IS....)
#define TREENODE_GET_PUSH_CONST_VAL(t) (t->val.num)

void optimize_expr(tree_node *t){
    if (!t) {
        fprintf(stderr, "[asopt1] Error: optimizing null tree ... asopt1 exiting\n");
        fprintf(out_file, "[asopt1] Error ...\n"); /* Make next stage stop */
        exit(EXIT_FAILURE);
    }

    /* Optimize operands recursively */
    for (int i=0; i < t->nops; i++){
        optimize_expr(t->ops[i]);
    }

    tree_node *tl = t->ops[0];
    tree_node *tr = t->ops[1];

    /* Binary constant operations */
    if (1 && TREENODE_IS_BINARY_OPERATOR(t) && (2 == t->nops) && TREENODE_IS_PUSH_CONST(tl) && TREENODE_IS_PUSH_CONST(tr) ) {
        int64_t lval = TREENODE_GET_PUSH_CONST_VAL(tl);
        int64_t rval = TREENODE_GET_PUSH_CONST_VAL(tr);
        if (1 && TREENODE_IS_ADD(t)) {
            t->val.num = lval + rval ;
        } else if (1 && TREENODE_IS_MULT(t)) {
            t->val.num = lval * rval ;
        } else if (1 && TREENODE_IS_AND(t)) {
            t->val.num = lval & rval ;
        } else if (1 && TREENODE_IS_OR(t)) {
            t->val.num = lval | rval ;
        } else if (1 && TREENODE_IS_XOR(t)) {
            t->val.num = lval ^ rval ;
        } else if (1 && TREENODE_IS_DIV(t)) {
            if (!(unsigned long)rval)
                t->val.num = 0 ; //For IVM64 x/0 = 0
            else
                t->val.num = (uint64_t)lval /  (uint64_t)rval; // unsigned div
        } else if (1 && TREENODE_IS_REM(t)) {
            if (!(unsigned long)rval)
                t->val.num = 0 ; //For IVM64 x%0 = 0
            else
                t->val.num = (uint64_t)lval % (uint64_t)rval; // unsigned rem
        } else{
                fprintf(stderr , "[asopt1] Error: ** UNREACHABLE,... asopt1 exiting");
                fprintf(out_file, "[asopt1] Error ...\n"); /* Make next stage stop */
                exit(EXIT_FAILURE);
        }
        // Do not change token type until the end, as it is compared to get node type !!
        t->token = TOKEN_PUSH8; // Let's put 8, as1 will adjust later the size of the bush on generating the binary
        t->valtype = VAL_NUM;
        t->nops = 0;
        t->npush = 1;
        free_tree_node_recursive(tl);
        free_tree_node_recursive(tr);
        n_opt++;
        return;
    }

    /* Unary constant operations */
    if (1 && TREENODE_IS_UNARY_OPERATOR(t) && (1 == t->nops) && TREENODE_IS_PUSH_CONST(tl)) {
        int64_t val = TREENODE_GET_PUSH_CONST_VAL(tl);
        if (1 && TREENODE_IS_NOT(t)) {
            t->val.num = ~val;
        } else if (1 && TREENODE_IS_POW(t)) {
            t->val.num = 1UL << val;
        } else{
                fprintf(stderr , "[asopt1] Error: ** UNREACHABLE,... asopt1 exiting");
                fprintf(out_file, "[asopt1] Error ...\n"); /* Make next stage stop */
                exit(EXIT_FAILURE);
        }
        // Do not change token type until the end, as it is compared to get node type !!
        t->token = TOKEN_PUSH8; // Let's put 8, as1 will adjust later the size of the bush on generating the binary
        t->valtype = VAL_NUM;
        t->nops = 0;
        t->npush = 1;
        free_tree_node_recursive(tl);
        n_opt++;
        return;
    }

    /* Cumulative operation (ADD, OR, XOR) with 0
       [<tree> push0 ADD] -> [<tree>]
    */
    if (1 && (TREENODE_IS_ADD(t) || TREENODE_IS_OR(t) || TREENODE_IS_XOR(t))) {
        /* IT IS NOT SAFE if the right-hand subtree mentions GETSP because if a tree with a
           GETSP goes up, the reference to the stack change !!!!*/
        if (TREENODE_IS_PUSH_CONST0(tr)) {
                copy_tree_node(t, tl); // Left the non-push0 node only
                free_tree_node(tl);
                free_tree_node(tr);
                n_opt++;
                return;
        } else if (TREENODE_IS_PUSH_CONST0(tl) && ! tr->mention_sp){
                copy_tree_node(t, tr); // Left the non-push0 node only
                free_tree_node(tl);
                free_tree_node(tr); // Do not free anything if conditions are not fulfilled
                n_opt++;
                return;
        }
    }

    /* absorption by 0 whit mult or and
       [push0 <tree> AND] -> [push0]
    */
    if (1 && (TREENODE_IS_MULT(t) || TREENODE_IS_AND(t))) {
        if (TREENODE_IS_PUSH_CONST0(tl) || TREENODE_IS_PUSH_CONST0(tr)) {
            if (TREENODE_IS_PUSH_CONST0(tl)) {
                    copy_tree_node(t, tl); // Note that push0 nodes has no operands
                    free_tree_node_recursive(tl);
                    free_tree_node_recursive(tr);
                    n_opt++;
                    return;
            }
            if (TREENODE_IS_PUSH_CONST0(tr)) {
                    copy_tree_node(t, tr);
                    free_tree_node_recursive(tl);
                    free_tree_node_recursive(tr);
                    n_opt++;
                    return;
            }
        }
    }

    /* Adding a constant twice
       [<tree> push const1 add push const2 add] -> [<tree> push (const1+const2) add]
    */
    if (1 && TREENODE_IS_ADD(t)) {
        if (1 && TREENODE_IS_ADD(tl) && TREENODE_IS_PUSH_CONST(tr) ) {
            tree_node *tll = tl->ops[0];
            tree_node *tlr = tl->ops[1];
            if (TREENODE_IS_PUSH_CONST(tlr)){

                    copy_tree_node(t->ops[0], tll); // Update t->ops[0], not the tl copy !
                    tr->val.num += tlr->val.num;

                    //free_tree_node(tlr);
                    n_opt++;
                    return;
            }
        }
        //if (1 && TREENODE_IS_PUSH_LABEL_PLUS_CONST(tl) && TREENODE_IS_PUSH_CONST(tr) ) {
        //}
    }



    /* Associative operation (+,*,&,|,^) with a constant twice
       [<tree> push const1 <OP> push const2 <OP>] -> [<tree> push (const1 <OP> const2) <OP>]
    */
    if (1 && TREENODE_IS_REDUX_OPERATOR(t)) {
        if (1 && TREENODE_IS_REDUX_OPERATOR(tl) && TREENODE_EQ_INSN(t, tl) && TREENODE_IS_PUSH_CONST(tr) ) {
            tree_node *tll = tl->ops[0];
            tree_node *tlr = tl->ops[1];
            if (TREENODE_IS_PUSH_CONST(tlr)){

                copy_tree_node(t->ops[0], tll); // Update t->ops[0], not the tl copy !
                /* Reduce constant operands*/
                if (TREENODE_IS_ADD(t)) {
                    tr->val.num += tlr->val.num;
                } else if (TREENODE_IS_MULT(t)) {
                    tr->val.num *= tlr->val.num;
                } else if (TREENODE_IS_AND(t)) {
                    tr->val.num &= tlr->val.num;
                } else if (TREENODE_IS_OR(t)) {
                    tr->val.num |= tlr->val.num;
                } else if (TREENODE_IS_XOR(t)) {
                    tr->val.num ^= tlr->val.num;
                }
               else{
                   fprintf(stderr , "[asopt1] Error: ** UNREACHABLE,... asopt1 exiting");
                   fprintf(out_file, "[asopt1] Error ...\n"); /* Make next stage stop */
                   exit(EXIT_FAILURE);
               }

                //free_tree_node(tlr);
                n_opt++;
                return;
            }
        }
    }


    /* This is an special case emitted as: "push8 label + const"
       [push label] [push const] [add] -> [push label+const]
    */
    if (1 && TREENODE_IS_ADD(t)) {
        if (TREENODE_IS_PUSH_LABEL(tl) && TREENODE_IS_PUSH_CONST(tr) ) {
            /* This special node contains two push operands, one
               with the label (left), and the other with the constant (right)*/
            t->token = TOKEN_PUSH_LABEL_PLUS_CONST;
            n_opt++;
            return;
        }
    }

    /* THIS IS DONE BY as1.y when generating bin */
    if (0 && TREENODE_IS_POW(t)){
        // [push const] [pow]-> [push 2^const] (whereas 2^const expands as one-byte)
        // (it will require modifiying as1.y to recognize a new "push label+const" pattern)
        // it saves one addition as the constant can be added directrly to the label offset
        if (TREENODE_IS_PUSH_CONST(tl)){
            uint64_t nlog = TREENODE_GET_PUSH_CONST_VAL(tl);
            if (nlog < 16) {
                // 2^const < 256         (1 byte, save space and time)
                // 256 <= 2^const < 2^16 (2 byte, save only time)
                if (nlog >= 0 && nlog < 8) {
                    t->token = TOKEN_PUSH1;
                }
                if (nlog >= 8 && nlog < 16) {
                    t->token = TOKEN_PUSH2;
                }
                t->valtype = VAL_NUM;
                t->val.num = 1UL << nlog; // push 2^n
                t->npush = 1;
                t->nops = 0;
                t->ops[0] = t->ops[1] = t->ops[2] = NULL;
                free_tree_node_recursive(tl);
                n_opt++;
                return;
            }
        }
    }
}

void optimize_current_bb(){
    for (long k=bb0; k<=bbE; k++){
        /* sequence of optimizations for each tree in current bb */
        optimize_expr(TStack[k]);
    }
}

int main(int argc, char *argv[]){

    /* This program has no arguments */

    TStack = (tree_node **)malloc(sizeof(tree_node*)*IVM64_BISON_MAX_PROG_SIZE);

    int r=0;
    out_file = stdout;
    r = yyparse(); /* Read from stdin*/

    optimize_current_bb();
    print_current_bb(); /* Print last BB, if any */

    #if (IVM64_BISON_AS_OPT_VERBOSE > 0)
    /* Print info about the optimizations */
    fprintf(stderr, "Found %d nodes (instructions/directives) / max. tree stack depth=%d\n", n_insn, n_max_stack);
    fprintf(stderr, "Found %d optimizations\n", n_opt);
    #endif

    free(TStack);

    return r;
}
